---
# cmd-ssh {{{1
ssh fetch file / show full path for scp (.cmd .ssh .inssh): 'sshfp() { printf "%q\n" "${USER}@${HOSTNAME}:$(realpath "$1")"; }; sshfp '

# cmd {{{1

what package owns file (.cmd .centos .rpm): rpm -q --whatprovides "$( which SOMEPACKAGE )"

show shared library dependencies of an ELF file (.cmd): |
    objdump -p FILE
    ldd FILE
run a command for each match in find (.cmd): |
    find . -type f -name "*.txt" -exec echo "{}" \;

git shallow clone (.cmd .git): git clone --depth 1 https://github.com/git/git.git
remove first n characters (.cmd .sh .bash): cut -c 5-
get size of a file (.cmd .sh .bash): stat --printf="%s" FILE
draw a full-width horizontal line in terminal (.cmd): |
  printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -

git set user config local for one repository (.cmd .git): |
  git config --local user.name "user"
  git config --local user.email "user@AM3I1w2WsJEa2MYWRWmk.com"

multiple arguments in shebang/shabang (.cmd): '#!/usr/bin/env -S command arg1 arg2 ...'

poor man's ps/top / list all processes/pids (.cmd): "( cd /proc; for pid in *; do [[ \"$pid\" != *[[:digit:]]* ]] && continue; printf \"%10s\\t%10s\\t%s\\n\" \"$pid\" \"$(stat -c \"%u (%U)\" \"$pid/loginuid\")\" \"$(tr -d '\\0' < \"$pid/cmdline\" | head -n 1)\"; done;)"

clean nohup (.cmd): 'nohup CMD &>/dev/null &'
resolve a dns/domain (.cmd): dig +short lwn.net

dont prompt for password for ssh call (.cmd .ssh): -o PasswordAuthentication=no

xargs for each line (.cmd .xargs): xargs -rL 1
xargs for each line w args (.cmd .xargs): xargs -I '{}' echo "{}"

get current branch (.git .cmd): |
    current_branch_full=$(git symbolic-ref HEAD)
    current_branch=${current_branch_full#"refs/heads/"}

remove/delete all lines matching (.sed .cmd): sed -i '/PATTERN/d' FILE
add empty line at beginning of file (.sed .cmd): sed -i '1i\\' FILE
add a prefix to each line (.sed .cmd): sed 's/^/prefix/'

# https://unix.stackexchange.com/a/264977
echo/print file contents from-to/between 2 matches (.sed .cmd): sed -n '/^pattern1/,${p;/^pattern2/q}'

# https://unix.stackexchange.com/a/80400
echo/print file contents after/from a match (.sed .cmd): sed '1,/^pattern1/d'

# https://unix.stackexchange.com/a/11323
echo/print file contents up to match (.sed .cmd): |
    # print up to and including the match
    sed '/pattern/q' filename
    # print up to BUT NOT including the match (GNU)
    sed '/pattern/Q' filename

find and replace line with group match/extract (.sed .cmd): sed -ri "s/^PREFIX:(.*)/# PREFIX:\1/" FILE
find and replace simple sed (.sed .cmd): sed -i 's/#en_US.UTF-8/en_US.UTF-8/' /etc/locale.gen
benchmark (startup) of a program (.cmd): hyperfine PROGRAM

git squash all commits into one (.cmd .git): | # https://stackoverflow.com/a/23486788
    git reset $(git commit-tree HEAD^{tree} -m "hello world")

git change commit messages of all commits/whole history (.cmd .git): |
    #!/bin/sh
    # https://stackoverflow.com/a/19681379

    git filter-branch -f --msg-filter \
    'sed "s/ezautocompl: //g"' \
    --tag-name-filter cat -- --all

git change author/commit-person of all commits/whole history (.cmd .git): |
    #!/bin/sh
    # https://stackoverflow.com/a/750182

    # NEW
    git-filter-repo \
        --name-callback 'return b"MYNAME"' \
        --email-callback 'return b"MYEMAIL"'

    # OLD
    git filter-branch --env-filter '
    OLD_EMAIL="your-old-email@example.com"
    CORRECT_NAME="Your Correct Name"
    CORRECT_EMAIL="your-correct-email@example.com"
    if [ "$GIT_COMMITTER_EMAIL" = "$OLD_EMAIL" ]
    then
        export GIT_COMMITTER_NAME="$CORRECT_NAME"
        export GIT_COMMITTER_EMAIL="$CORRECT_EMAIL"
    fi
    if [ "$GIT_AUTHOR_EMAIL" = "$OLD_EMAIL" ]
    then
        export GIT_AUTHOR_NAME="$CORRECT_NAME"
        export GIT_AUTHOR_EMAIL="$CORRECT_EMAIL"
    fi
    ' --tag-name-filter cat -- --branches --tags

git apply a patch (.cmd .git):
    git am PATCHFILE
git create a patch (.cmd .git):
    git format-patch -1 HEAD
git clone repository through subtree (.cmd .git):
    git subtree add --prefix SUBDIR REPOSITORY HEAD --squash
git read/fetch/get hash/commit from remote repository (.cmd .git):
    git ls-remote PKG HEAD | cut -f1
uninstall a package (.cmd .go): go clean -i IMPORTPATH

ocr a pdf (.cmd): ocrmypdf -l eng,deu INPDF OUTPDF
mount an iso (.cmd): sudo mount -o loop ISOPATH MOUNTPATH

start a http server (.cmd):
    cmd: bash
    stdin: |
      random_digit() { grep -m1 -ao '[0-9]' /dev/urandom | sed s/0/9/ | head -n1; }
      printf "npx --no-install http-server -p 80%s%s -a 127.0.0.1 ." "$(random_digit)" "$(random_digit)"

curl upload json from stdin (.cmd): |
    curl -X POST --data-binary "@-" \
        -H "Content-Type: application/json" \
        URL
curl download a file like wget (.cmd): curl -L -O URL
nmap list all IPs on LAN (.cmd): nmap -sP 192.168.0.0/24
autoformat html (.cmd): tidy -i -w 100 SOMEHTMLFILE

gcc build static library:
    gcc -c -o out.o main.c && ar rcs libout.a out.o

dbus debug / explore (.cmd .dbus): d-feet
dbus list services (.cmd .dbus): qdbus && qdbus --system
dbus monitor services (.cmd .dbus): sudo dbus-monitor --system "type='signal',sender='net.connman'"

create archive / recursive tar compression (.cmd): tar -czvf backup.tar.gz folder
list archive (.cmd): tar -tvf archive.tar

youtube-dl download all subtitles (w/ auto-subs) (.cmd): "youtube-dl --skip-download --write-auto-sub --all-subs"
youtube-dl download specific/eng subtitles (w/ auto-subs) (.cmd): "youtube-dl --skip-download --write-auto-sub --sub-lang en"

check priv key (.cmd .ssh): FILE=""; ssh-keygen -lf "$FILE"; ssh-keygen -yf "$FILE"
# https://wiki.archlinux.org/index.php/SSH_keys#Ed25519
create key (.cmd .ssh): ssh-keygen -o -t ed25519 -C "user@hostname" -f OUTPUTFILE

# https://superuser.com/a/692184
create random text (.cmd): base64 --wrap=0 /dev/urandom | head -c 64
create random bytes (.cmd): head -c $(( 128 * 1024 )) < /dev/urandom

7zip extract archive into subdir (.cmd): 7z e ISOPATH -o./out

restart / reboot (.win .cmd): shutdown -r -t 5
list processes / tasks (.win .cmd): tasklist
kill a process by name (.win .cmd): taskkill /F /IM firefox.exe
kill a process by pid (.win .cmd): taskkill /F /PID 0000

add new user (.linux .cmd):  useradd -m USERNAME
add new group (.linux .cmd): groupadd GROUP
add user to group (.linux .cmd): usermod -aG GROUP USER
list/show application with open ports (.linux .ssh): sudo ss -tulpn
update mirrorlist (.arch .linux .cmd): tmpfile=$(mktemp); curl -L -s 'https://archlinux.org/mirrorlist/?country=AT&country=DE&protocol=https&use_mirror_status=on' | sed -e 's/^#Server/Server/' -e '/^#/d' | rankmirrors -n 5 - > "$tmpfile"; sudo mv "$tmpfile" "/etc/pacman.d/mirrorlist"

create new svn branch (.svn .cmd): svn copy \\\n
    "http://from" \\\n
    "http://to" \\\n
    -m "Creating branch 'm2suite_19.4' from 'm2suite_19.2'"

# cmd-ffmpeg {{{1
ffmpeg convert audio to highest quality ogg (.cmd): ffmpeg -i INP -c:a libvorbis -q:a 10 OUT
convert audio to highest quality ogg (.cmd .ffmpeg): ffmpeg -i INP -c:a libvorbis -q:a 10 OUTP
normalize audio (.cmd .ffmpeg): ffmpeg -i INP -filter:a "loudnorm=I=-16:TP=-3:LRA=4" -c:v copy OUTP

# c {{{1
string to integer (.c99): |
  #include <inttypes.h>

get own pid (.c .linux): |
  #include <sys/types.h>
  #include <unistd.h>

  pid_t pid = getpid();

list all running pids (.c .linux): |
  struct dirent *entry;
  DIR *d;

  if (!(d = opendir("/proc")))
     return;

  while (entry = readdir(d)) {
     puts(entry->d_name);
  }

  closedir(d);
print to stderr (.c): fprintf(stderr, "\n");

# cpp {{{1
closure by ref (.cpp .c++): |
  [&]{
  };
print to stderr (.cpp .c++): std::cerr << msg << std::endl;

switch (.cpp .c++): |
  enum color {RED, GREEN, BLUE};
  switch(RED) {
      case RED:   std::cout << "red\n"; break;
      case GREEN: std::cout << "green\n"; break;
      case BLUE:  std::cout << "blue\n"; break;
  }

throw/raise exception (.cpp .c++): throw std::runtime_error("ERROR");
catch all exceptions (.cpp .c++): |
  try {
    // ...
  } catch(std::exception const & ex) {
    // ...
  } catch(...) {
    // ignore ex
  }


print / cout (.cpp .c++): std::cout << "FOO" << std::endl;
system notify-send (.cpp .c++): system("notify-send qwe asd");

# golang {{{1
check/test if application/program/command exists/is installed (.golang): |
    path, err := exec.LookPath("PROG")
    if err != nil {
        panic(err)
    }
replace/override dependency to local one in go.mod (.golang): |
    module github.com/pselle/foo

    replace github.com/pselle/bar => /Users/pselle/Projects/bar

    require (
        github.com/pselle/bar v1.0.0
    )
int to string (.golang): strconv.Itoa(999)
check if stdin is terminal/tty (.golang): |
    stat, _ := os.Stdin.Stat()
    if (stat.Mode() & os.ModeCharDevice) != 0 {
        fmt.Println("stdin is from a terminal")
    }
convert between fixed-sized array & slice (.golang): |
    s := []int{1, 2, 3}
    var a [3]int

    fmt.Println(copy(a[:2], s))  // 2
    fmt.Println(a)               // [1 2 0]
die usage usageAndDie (.golang): |
    func die(retCode int, a ...interface{}) {
      fmt.Fprintln(os.Stderr, a...)
      os.Exit(retCode)
    }
    func dief(retCode int, format string, a ...interface{}) {
      fmt.Fprintf(os.Stderr, format, a...)
      os.Exit(retCode)
    }
    func usage(retCode int) {
      f := os.Stderr
      if retCode == 0 {
        f = os.Stdout
      }

      fmt.Fprintln(f, "usage: [-h|--help] <file>")
      os.Exit(retCode)
    }
    func usageAndDie(retCode int, a ...interface{}) {
      fmt.Fprintln(os.Stderr, a...)
      usage(retCode)
    }
cli basic/flags (.golang): |
    wordPtr := flag.String("word", "foo", "a string")

    numbPtr := flag.Int("numb", 42, "an int")
    forkPtr := flag.Bool("fork", false, "a bool")

    var svar string
    flag.StringVar(&svar, "svar", "bar", "a string var")

    flag.Parse()

    fmt.Println("word:", *wordPtr)
    fmt.Println("numb:", *numbPtr)
    fmt.Println("fork:", *forkPtr)
    fmt.Println("svar:", svar)
    fmt.Println("tail:", flag.Args())

get current date / now / timestamp / unix/posix-time (.golang): time.Now()
create random bytes (.golang): |
    token := make([]byte, 4)
    rand.Read(token)

open/read bytes a file (.golang): |
    f, err := os.Open(FILEPATH)
    if err != nil {
        log.Fatal(err)
    }
    buf := new(bytes.Buffer)
    _, err = buf.ReadFrom(f)
    if err != nil {
        log.Fatal(err)
    }
    f.Close()

repeat a string x times (.golang): strings.Repeat(".", 4)
create a temporary file (.golang): |
    of, err := ioutil.TempFile("", "testapp")
    defer os.Remove(of.Name())
    defer os.Close(of.Name())

check if error is type/subtype of an error type (.golang): |
    switch err.(type) {
    case *fs.PathError:
        break
    default:
        panic(err)
    }

reflect/print/determine type of pointer during runtime (.golang): println(reflect.ValueOf(err).Type().String())

free a pointer (.golang .cgo): C.free(fooPtr)
create a void pointer (.golang .cgo): nullPtr := unsafe.Pointer(nil)
malloc a cstring (.golang .cgo): |
    foo := C.malloc(C.ulong(10 * 10))
    foop := unsafe.Pointer(foo)
    fooc := C:GoString((*C.char)(foop))

timeout for a goroutine (.golang .cncr .goroutine): |
    select {
    case <-time.After(3 * time.Second):
        return fmt.Error("timeout")
    }

sync/wait for multiple goroutines via waitgroup (.golang .cncr .goroutine): |
    var wg sync.WaitGroup

    somefunc := func(wg *sync.WaitGroup) {
        defer wg.Done()
        time.Sleep(1 * time.Second)
    }

    for i := 1; i <= 5; i++ {
        wg.Add(1)
        go somfunc(&wg)
    }

    wg.Wait()

append text to a file (.golang): |
    f, err := os.OpenFile(FILEPATH, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
    if err != nil {
        log.Fatal(err)
    }

    defer f.Close()
    if _, err := f.WriteString("text to append\n"); err != nil {
        log.Fatal(err)
    }

cast os.FileInfo.Sys() to OS stat_t (.golang): |
    // linux
    if stt, ok := VAR_FILE_INFO.Sys().(*syscall.Stat_t); ok {
    }

os specific build flags (.golang): |
    // +build linux
    // +build windows
    // +build darwin

get string reader from string (.golang):
  strings.NewReader("Foo")

base/top-level/background context (.golang): context.Background()

write bytes to file(.golang): |
  d1 := []byte("hello\ngo\n")
  err := ioutil.WriteFile("/tmp/dat1", d1, 0755)
  if err != nil {
    log.Fatal(err)
  }

string in/contains/has string (.golang): strings.Contains(str, substr)
sleep (.golang): time.Sleep(2 * time.Second)

touch/create a file (.golang): |
    if fi, err := os.Stat(path); err != nil || fi.IsDir() {
        file, err := os.Create("temp.txt")
        file.Close()
    }

join array of strings (.golang): strings.Join(lines, "\n")
regex extract groups (.golang): |
    var rePattern *regexp.Regexp = regexp.MustCompile(`^\.\-(.*)-(\d\d\d\d).bak$`)
    matches := rePattern.FindStringSubmatch(fname)
    // either returns [] if no match or [whole match, group1, group2, ...]

string match regex (.golang): |
    match, _ := regexp.MatchString("p([a-z]+)ch", "peach")
    r, _ := regexp.Compile("p([a-z]+)ch")
    r.MatchString("peach")

print the type of a variable at runtime (.golang .reflection): fmt.Println(reflect.TypeOf(fooVar).String())
string to int (.golang): |
    // for `int`
    i, err := strconv.Atoi("-42")
    // for `int64` ...
    i, err := strconv.ParseInt(s, 10, 64)
    // for other "number types" see `strconv.Parse...`
parse int from string (.golang): s := strconv.Itoa(-42)

read stdin (.golang): bytes, err := ioutil.ReadAll(os.Stdin)
pop off array (.golang): fooArr = fooArr[:len(fooArr)-1]

try to cast a type (.golang): |
    if s, ok := fooVal.(string); ok {
    }


check type runtime / type switch (.golang): |
    switch t := foo.(type) {
        case map[interface{}]interface{}:
        case string:
        default:
            fmt.Printf("unexpected type %T\n", t)
    }

resolve symlinks (.golang): resolved, err := filepath.EvalSymlinks(fooPath)

check if map contains/in key (.golang): |
    if val, ok := dict["foo"]; ok {
    }

strip/trim string (.golang): strings.TrimSpace(" qwe ")

split string (.golang): strings.Split("a,b,c", ",")

get user/home directory/path (.golang): |
    user, err := user.Current()
    homeDir := user.HomeDir

check if file exists (.golang): |
    if fi, err := os.Stat(fooPath); err != nil {
        log.Fatal(err)
    } else if fi.IsDir() {
        log.Fatalf(`stat %s: is a directory, expected to be file`, fooPath)
    }

parse / dump json (.golang): |
    type Foo struct {
        A string   `json:"a"`
        B []string `json:"b"`
    }
    foo := make(map[interface{}]interface{})

    err = json.Unmarshal([]byte(fooString), &foo)
    if err != nil {
        panic(err)
    }

    fooOutput, err := json.Marshal(&foo)
    if err != nil {
        panic(err)
    }

join paths (.golang): path.Join(fpath, "foo")

get parent directory of path (.golang): parent := filepath.Dir(fpath)

list directory (.golang): |
    files, err := ioutil.ReadDir("./")
    if err != nil {
        panic(err)
    }

    for _, f := range files {
            fmt.Println(f.Name())
    }

get/set working directory (.golang): |
    wd, err := os.Getwd()
    if err != nil {
        panic(err)
    }

    err = os.Chdir(wd)
    if err != nil {
        panic(err)
    }

base64 (.golang): |
    fooData := []byte("some input")
    str := base64.StdEncoding.EncodeToString(fooData)
    data, err := base64.StdEncoding.DecodeString(str)
    if err != nil {
        panic(err)
    }

string starts with/prefix (.golang): strings.HasPrefix("fooBar", "foo")
pushd / popd / change dir (.golang): |
    wd, err := os.Getwd()
    if err != nil {
        panic(err)
    }

    err = os.Chdir(filepath.Join(wd, "fooPath"))
    if err != nil {
        panic(err)
    }

    // ...

    err = os.Chdir(wd)
    if err != nil {
        panic(err)
    }

parse / dump yaml (.golang): |
    // "gopkg.in/yaml.v3"
    type Foo struct {
        A string   `yaml:"pa,omitempty"`
        B []string `yaml:",flow,omitempty"`
    }
    foo := make(map[interface{}]interface{})

    err = yaml.Unmarshal([]byte(fooString), &foo)
    if err != nil {
        panic(err)
    }

    fooOutput, err := yaml.Marshal(&foo)
    if err != nil {
        panic(err)
    }

get args (.golang): |
    args := os.Args[1:]

print to stderr (.golang): |
    fmt.Fprintf(os.Stderr, "number of foo: %d", nFoo)

create directory with parents / mkdir -p (.golang): os.MkdirAll(fooPath, 0755)
check if path is existing directory (.golang): |
    // check if file is dir
    if fi, err := os.Stat(fooPath); err != nil {
        log.Fatal(err)
    } else if !fi.IsDir() {
        log.Fatalf(`stat %s: not a directory`, fooPath)
    }

get keys of a map (.golang): |
    fooKeys := make([]string, len(barMap))
    { // get map keys
        i := 0
        for k := range barMap {
            fooKeys[i] = k
            i++
        }
    }

hash a string/byte array (.golang): sha256.Sum256([]byte("hello world\n"))

read a file (.golang): contents, err := ioutil.ReadFile()

# http://rosettacode.org/wiki/Walk_a_directory/Recursively#Go
abspath / realpath (.golang): |
    fpathAbs, err := filepath.Abs(fpath)
    if err != nil {
        panic(err)
    }

check stat if symlink and resolve (.golang): |
    if fi.Mode()&os.ModeSymlink != 0 {
        link, err := os.Readlink(fi.Name())
        if err != nil {
            panic(err)
        }
    }

walk directory recursively (.golang): |
    err := filepath.Walk(".", func(fpath string, fi os.FileInfo, err error) error {
        if err != nil {
            fmt.Fprintf(os.Stderr, "stumbled while walking %v\n", err)
            return nil
        }

        if fi.IsDir() {
            return nil
        }

        matched, err := filepath.Match("*.*", fi.Name())
        if err != nil {
            return err
        }

        if matched {
            fmt.Println(fpath)
        }

        return nil
    })
    if err != nil {
        panic(err)
    }

get/set env (.golang): |
    os.Setenv("FOO", "1")
    fooEnv := os.Getenv("FOO")

enum (.golang): |
    type KindEnum string
    const (
        KindA KindEnum = "A"
        KindB = "B"
    )

foreach line in string (.golang): |
    scanner := bufio.NewScanner(strings.NewReader("some string"))
    for scanner.Scan() {
        fmt.Println(scanner.Text())
    }
    if err := scanner.Err(); err != nil {
        panic(err)
    }

write string to file (.golang): |
    err := ioutil.WriteFile("/tmp/dat1", []byte("test"), 0755)
    if err != nil {
        panic(err)
    }

fetch from http (.golang): |
    resp, err := http.Get(URL)
    if err != nil {
        panic(err)
    }
    defer resp.Body.Close()

    rawContents, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        panic(err)
    }

    contents = string(rawContents)

run/exec/subprocess and capture (.golang): |
    cmd := exec.Command(cmdArg, args...)

    var stdoutBuf, stderrBuf bytes.Buffer
    cmd.Stdout = &stdoutBuf
    cmd.Stderr = &stderrBuf
    // cmd.Stdout = os.Stdout
    // cmd.Stderr = os.Stderr

    err := cmd.Run()
    if err != nil {
        if exitError, ok := err.(*exec.ExitError); ok {
            return "", fmt.Errorf("command exited with code %d", exitError.ExitCode())
        }
    }

    outStr, errStr := string(stdoutBuf.Bytes()), string(stderrBuf.Bytes())
    return 0, outStr, errStr

cli cobra (.golang): |
    import (
        "fmt"
        "os"

        "github.com/spf13/cobra"
    )

    var (
        flagDebug bool
    )

    var rootCmd = &cobra.Command{
        Use: "usher ...",
        // Short: "",
        Long: "",
        Args: cobra.ExactArgs(1),
        Run: func(cmd *cobra.Command, args []string) {
            // @TODO
        },
    }

    var subCmd = &cobra.Command{
        Use: "exec [host]",
        // Short: "",
        // Long:  "",
        Args: cobra.ExactArgs(1),
        Run: func(cmd *cobra.Command, args []string) {
            // @TODO
        },
    }

    func init() {
        rootCmd.AddCommand(subCmd)
        rootCmd.PersistentFlags().BoolVar(&flagDebug, "debug", false, "Enable debug output")
    }

    func main() {
        if err := rootCmd.Execute(); err != nil {
            fmt.Println(err)
            os.Exit(1)
        }
    }

unittest (.golang): |
    // main_test.go
    package main

    import (
        "testing"

        "github.com/stretchr/testify/assert"
    )

    func TestPrint(t *testing.T) {
        output := "OK"
        assert.Equal(t, "OK", output)
        if output != "OK" {
            t.Fatal("output ain't \"OK\"")
        }
    }

main (.golang): |
    package main

    import (
        "fmt"
    )

    func main() {
        fmt.Printf("%s\n", "Main here")
    }

# groovy {{{1
for key value/entries in map (.groovy): |
    [foo:90, bar:80].each{ key, val -> println("${key}: ${val}") }
    [foo:90, bar:80].eachWithIndex{ entry, index -> println("${entry.key}: ${entry.value} ($index)") }

    for (entry in [foo:90, bar:80]) {
        println("$entry.key: $entry.value")
    }
print to stderr (.groovy .java): System.err.println(MSG)
read a file (.groovy): |
    def text = new File("SOMEFILE").getText()

new custom exception (.groovy): |
    public class MyCustomException extends Exception { MyCustomException(String msg){super(msg)} }

# jenkins {{{1
print/list contents of workspace (.jenkins): |
    sh 'find . -name "*"'

# lua {{{1
hello world / main (.lua): |
  print("Hello World")

subprocess / spawn / communicate (.lua): |
  fp = io.popen("foo >/tmp/unique", "w")
  fp:write(anything)
  fp:close()
  fp = io.open("/tmp/unique")
  x = read("*a")
  fp:close()

# nim {{{1
print to stderr (.nim): |
    writeLine(stderr, MSG)
    flushFile(stderr)
parse/string to enum (.nim): |
    import strutils
    parseEnum[ENUM](STRVAR)
string starts with/prefix (.nim): |
    import strutils
    someString.startsWith("PREFIX")
get args (.nim): |
  let args = commandLineParams()
read a file (.nim): |
    let contents = io.readFile(PATH)
read stdin (.nim): |
    let contents = stdin.readAll()
throw/raise exception (.nim): raise newException(Exception, MSG)
parse int from string (.nim): |
    import parseutils
    var res: uint
    discard parseUInt("3450", res)
check if file exists (.nim): os.fileExists(FILEPATH)
check if dir exists (.nim): os.dirExists(DIRPATH)
create directory with parents / mkdir -p (.nim): os.createDir(FILEPATH)
expand user/home (.nim): |
    import os
    getHomeDir()
    expandTilde("~/.config")
converter (.nim): |
    converter toBool(x: int): bool = x != 0

# python {{{1

cd/change dir to script parent location path (.python): |
    # cd to parent dir of current script
    os.chdir(os.path.dirname(os.path.realpath(__file__)))

require minimum python version (.python): |
    import sys
    MIN_PYTHON = (2, 6)
    if sys.version_info < MIN_PYTHON:
        sys.exit("Python %s.%s or later is required." % MIN_PYTHON)

lock a file / synchronize file access among processes / flock (.python .linux): |
  import fcntl
  import io
  class LinuxFileLock():
      """ Blocks on a file-lock. Will not work if a single process has multiple fd to the same file. """
      def __init__(self, inp):
          if isinstance(inp, str):
              self.f = open(inp, "r+")
          elif isinstance(inp, io.IOBase):
              self.f = inp
              if not self.f.writable() or \
                  not self.f.readable(): raise Exception("File needs to be writeable and readable.")
          else: raise Exception("Unsupported type: " + str(type(inp)))
          self.fd = self.f.fileno()

      def __enter__(self):
          fcntl.lockf(self.fd, fcntl.LOCK_EX)
          return self.f

      def __exit__(self, type, value, traceback):
          fcntl.lockf(self.fd, fcntl.LOCK_UN)
          self.f.close()

cat/print a file (.python): |
  def cat(path):
      with open(path, "r") as f: print(f.read(), flush=True)

cli / NO argparse (.python): |
  def die(msg, code=1):
      print(msg, file=sys.stderr)
      quit(code)
  def usage(code=0):
      print((
          f"usage: [-h|--help] <file>\n"
          f"version: 1.0"
      ), file=sys.stderr)
      quit(code)
  def usage_and_die(msg, code=1):
      print(msg, file=sys.stderr)
      usage(code)

  def cli():
      own_path  = sys.argv[0]
      own_fname = os.path.basename(own_path)
      args      = sys.argv[1:]
      args_len  = len(args)

      if any(arg in args for arg in ["-h", "--help"] ):
          usage()
      if (args_len != 2):
          usage(1)

read lines of file without newlines at end (.python): |
  with open(FILE_PATH, "r") as f:
      lines = f.read().splitlines()
basic timeout (.python .posix): |
  import signal

  def timeout_handler(signum, frame):
      raise Exception("timeout")
  signal.signal(signal.SIGALRM, timeout_handler)
  signal.alarm(10)
  signal.alarm(0) # cancel
remove/delete/unlink a file (.python): |
  from pathlib import Path
  Path(FILE_PATH).unlink()
touch/create a file (.python): |
  from pathlib import Path
  Path(FILE_PATH).touch()
defer exit (.python): |
  import atexit

  def exit_handler():
      print("EXIT_HANDLER")

  atexit.register(exit_handler)
walk directory recursively (.py): |
    import fnmatch
    import os

    for root, dirs, files in os.walk("."):
        for filename in files:
            print( os.path.join(root, filename))

sh subprocess capture stdout no check / flexible/complex (.python): |

    import subprocess
    from subprocess import PIPE,DEVNULL,STDOUT

    def sh(*args, check=True, timeout=None, shell=False, **kwargs):
        if shell: args = args[0]
        cp = subprocess.run(args, stdout=PIPE, check=check, timeout=timeout, shell=shell, **kwargs)
        return cp.stdout.decode(), cp

    print(sh("echo err >&2", shell=True, stderr=STDOUT)[0])
define custom exception (.python): |
    class CustomException(Exception): pass

die usage usage_and_die (.python): |
    def die(*msgs, exit_status=1):
        print(*msgs, file=sys.stderr)
        exit(exit_status)

check/test if application/program/command exists/is installed (.python): |
    from shutil import which
    secret_tool = which("secret-tool")
    if secret_tool == None:
        print("oh no")
    else:
        print(f"absolute path to bin: {secret_tool}")

get environment variable (.python): os.environ["PATH"]
move a file (.python): |
    import shutil
    shutil.move(FROM, TO)

check if file exists (.python): os.path.isfile(FILEPATH)
read/get file size via stat (.python): os.stat(FILEPATH).st_size

remove prefix (.python): '"foo: bar".removeprefix("foo: ")'

extract group from compiled regex (.python): |
    import re
    re_number_sep    = re.compile(r':([0-9]+):')
    number_seperator = next(re_number_sep.finditer(line))
    group0           = number_seperator.groups()[0]

check if stdin is terminal/tty (.python): |
    if sys.stdout.isatty():
        print("tty")
    else:
        print("non-tty")

typeannotations (.python): |
    from typing import *
    name: str
    unit_prices: List[float]
    map: Dict[str, int]
    quantity_on_hand: int = 0

path relative to current script (.python): scriptpath = os.path.dirname(__file__)

get own pid (.python): |
  import os
  os.getpid()

write to file (.python): |
    with open(FILEPATH, "w") as f:
        f.writelines()
        f.write()

if regex matches (.python): |
    if re.search(r"chromium", wincmdline, flags=re.IGNORECASE):

for key value/entries in dict (.python): |
    for k, v in DICT.items():
        pass

check if dir exists (.python): os.path.isdir("path")
check if object has method/key (.python): |
    if hasattr(obj, "property"):
        pass

sleep (.python): |
    import time
    time.sleep(10)

raise exception (.python): raise Exception("Smelly socks") from e

expand user/home (.python): |
    os.path.expanduser("~/.config")

enum (.python): |
    from enum import Enum, auto as EnumAuto
    class Color(Enum):
        RED = EnumAuto()
        BLUE = EnumAuto()
        GREEN = EnumAuto()

print to stderr (.python): |
    print(*args, file=sys.stderr, **kwargs)
    sys.stderr.write("foo\n")

read stdin (.python): contents = sys.stdin.read()

get args (.python): |
    args = sys.argv[1:]
    print(sys.argv)

read a file (.python): |
    with open(foo_path) as f:
        contents = f.read()

create directory with parents / mkdir -p (.python): os.makedirs(os.path.dirname(FILEPATH), exist_ok=True)

run/exec a shell command/subprocess (.python): |
    import subprocess
    subprocess.check_call("nmap -v -oG - -sn 192.168.1.0/24", shell=True)
    subprocess.check_output("nmap -v -oG - -sn 192.168.1.0/24", shell=True)

# @TODO named-groups
# @TODO just test for a match
regex capture groups (.python): |
    import re
    result = re.search(r'Host:\ ([^\ ]+)\ \((.*)\)', input_string, flags=re.IGNORECASE | re.X)
    result_groups = result.groups()
    assert len(result_groups) == 2
    print(result_groups[0])

get duration/time difference as unix/posix timestamp from date command format-string (.python): |
    def posix_time_at(time_string):
        return int(sh("date", "-d", time_string, "+%s", check=True)[0].strip())

get current date / now / timestamp / unix/posix-time (.python): |
    from datetime import datetime, timezone
    now_iso_8601 = datetime.now(timezone.utc).astimezone().isoformat()
    now_posix = datetime.now().timestamp()

    from_posix = datetime.fromtimestamp(1642954569)

if main (.python): |
    #!/usr/bin/env python3
    import sys

    def main():
        pass

    if __name__ == "__main__":
        main()

cli / argparse (.python): |
    import argparse
    parser = argparse.ArgumentParser(description="A description of the Program")

    parser.add_argument("from_path", metavar="from", type=str, nargs="?", help="from this location")
    parser.add_argument("integers", metavar="N", type=int, nargs="+", help="an integer for the accumulator")

    parser.add_argument("-e", "--any-enum", dest="any_enum", type=str, choices=["lf", "cr", "crlf"], default="cr", help="Some enums")
    parser.add_argument("-f", "--any-flag", dest="any_flag",action="store_true", help="A flag")
    parser.add_argument("-s", "--any-string", dest="any_string",type=str, default="default", help="A string")
    parser.add_argument("-ss", "--any-strings", dest="any_strings", type=str, nargs="?", help="Multiple strings")

    parser.add_argument("rest", nargs=argparse.REMAINDER, help=argparse.SUPPRESS)

    args = parser.parse_args(sys.argv[1:])

dataclass (.python): |
    from dataclasses import dataclass
    from typing import *

    @dataclass
    class InventoryItem:
        name: str
        unit_prices: List[float]
        quantity_on_hand: int = 0

        def total_costs(self) -> List[float]:
            return [ price * self.quantity_on_hand for price in self.unit_prices ]

# javascript / typescript {{{1
write to file (.js .ts .node): fs.writeFileSync(PATH, STRING)
change dir (.js .ts .node): process.chdir(NEW_DIR);
print to stderr (.js .ts .node): console.error(MSG);
print to stderr (.js .ts .node): console.error(MSG);
sh subprocess capture stdout no check / flexible/complex (.js .ts .node): |
    const childProcess = require("child_process");

    /** Flexible child_process spawn-wrapper. */
    function sh(options={}, cmd, ...args) {
        options = {
            check: true,
            encoding: "utf-8",
            shell: false,
            stdio: ['inherit', 'pipe', 'pipe'],
            timeout: undefined,
            trimFinalNewline: true,
            ...options,
        }

        const result = childProcess.spawnSync(cmd, args, {
            encoding: options.encoding,
            shell: options.shell,
            stdio: options.stdio,
            timeout: options.timeout,
            ...options,
        });

        if (options.check && result.error) {
            throw result.error;
        }

        if (options.trimFinalNewline && result.stdout.length >= 2) {
            result.stdout = (result.stdout[result.stdout.length-2] === '\r') ?
                result.stdout.slice(0, -2) : result.stdout.slice(0, -1)
        }

        return [ result.stdout, result ];
    }

    const res = sh({}, cmd, "args")[0];
    console.log(res);

keys in object (.js): Object.keys(SOMEOBJ)
sleep (.js): |
    async function sleep(ms) {
        return new Promise((succ) => {
            setTimeout(succ, ms);
        });
    }

get path to local file relative to script path/dir (.js .node): |
    `${__dirname}/FILE`
capture a regex group (.js): |
    const imageDescription = 'This image has a resolution of 1440×900 pixels.';
    const regexpSize = /([0-9]+)×([0-9]+)/;
    const match = imageDescription.match(regexpSize);
    console.log(`Width: ${match[1]} / Height: ${match[2]}.`);

move a file (.js .node): fs.renameSync(BEFORE, AFTER)
read whole stdin synchronously (.js .node): |
    const fs = require("fs");
    const response = fs.readFileSync(process.stdin.fd).toString();
read line by line from stdin async (.js .node): |
    // read line by line from stdin
    const rl = require("readline").createInterface({
        input: process.stdin,
        output: process.stdout,
        terminal: false,
    });
    for await (const line of rl) {
        console.log(line);
    }

string starts with/prefix (.js .ts): someString.startsWith("PREFIX")
throw exception (.js .ts): throw new Error("OHNO");
for each key/val in object/dictionary (.js .node .ts): |
    for (const [key, val] of Object.entries(fooObj)) {
        //
    }

check if dir exists (.js .node .ts): |
    (await fs.promises.stat(path)).isDirectory()

exit/quit (.js .node .ts): |
    process.exit(0)

read a file (.js .node .ts): |
    import * as fs from "fs";
    await fs.promises.readFile(file, "utf8");
    fs.readFileSync(file, "utf8");

for each line in string (.js .ts): |
    for (const line of INPUTSTR.split("\n")) {
        console.log(line+"<>");
    }

create directory with parents / mkdir -p (.js .node .ts): |
    fs.mkdirSync(fooPath, { recursive: true })

if main (.js .node .ts): |
    #!/usr/bin/env node
    function main(args) {
        console.log(`hello world! I see you passed me ${args}, how nice of you!`);
        return 0;
    }

    if (typeof require !== 'undefined' && require.main === module) {
        process.exitCode = main(process.argv.slice(2));
    }

# json-schema {{{1
enum (.json-schema): |
    "type": "array",
    "items": {
        "type": "string",
        "enum": ["one", "two", "three"]
    }

# bash {{{1
shellcheck disable single run (.sh .bash): |
    # shellcheck disable=SC2039
clean/remove dir/file (.sh .bash): |
    clean() { { [ -d "$1" ] && rm -rf "$1" ;} || { [ -f "$1" ] && rm "$1"; } || true; }
back/stacktrace an error (.bash): |
    function trace_err () {
        local line="${BASH_LINENO[0]}"
        local src="${BASH_SOURCE[0]}"
        echo "  ↑ from ${src}:${line} → $(sed "${line}q;d" "$src")"
    }; set -o errtrace; trap 'trace_err' ERR
read output into array (.bash):
    readarray -t VAR < <(CMD)
read file into variable (.bash):
    VAR=$(<FILE)
if output contains/has line (.cmd .sh .bash): |
    if grep -q "SOMELINE" "SOMEFILE"; then
        echo "FOUND"
    fi
print an associative array (.bash): |
    printaarr() { declare -n __p="$1"; for k in "${!__p[@]}"; do printf "%s=%s\n" "$k" "${__p[$k]}"; done;  }
spread associative array (.bash): |
    spread() { printf "for k in \"\${!%s[@]}\"; do %s[\$k]=\${%s[\$k]}; done\n" "$2" "$1" "$2"; }
    eval "$(spread ft f1)"
count lines (.cmd .sh .bash): wc -l FILE
trim a string (.bash): sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//'
build args via array (.bash): |
    args=(
        arg1
    )
    args+=(arg2)

    argsLen=${#args[@]}

    if [[ "${#args[@]}" -gt 0 ]]; then
        echo "has args"
    fi

    for arg in "${args[@]}"; do
        echo $args
    done
    myfunc "${args[@]}"

remove/delete last characters (.sh .bash): '"${var::-3}"'
nonsecure hash function (.sh .bash): |
    nonsecure_hashfn() { local hash; hash=$(cksum -); printf "%s" "${hash%%\ *}"; }
secure hash function (.sh .bash): |
    secure_hashfn() { local hash; hash=$(sha256sum -); printf "%s" "${hash::-3}"; }
swap stdout/stderr (.sh .bash): 3>&1 1>&2 2>&3
printf stdin (.bash): "{ stdin=\"\"; read -r -d '' -u 0 stdin; printf \"%q\" \"$stdin\"; }"
read stdin (.sh .bash): stdin=$(cat)
split a variable by character x times (.bash): |
    IFS=';' read -r first rest <<< "$variable"
split a variable by character into an array (.bash): |
    IFS='€' read -ra stat <<< "$variable"
get last line (.sh .bash): tail -n 1
get first line (.sh .bash): head -n 1
remove/delete first line (.sh .bash): tail -n +2
remove/delete last line (.sh .bash): head -n -1
echo/print/extract contents from-to/between 2 matches/lines (.bash): |
    between_2_lines() {
        local found_begin=
        local found_end=
        while read -r line; do
            if [[ $found_end ]]; then
                : # skip silently, without breaking pipe
            elif [[ ! $found_begin ]]; then
                if [[ $line =~ $1 ]]; then
                    found_begin=1
                fi
            else
                if [[ $line =~ $2 ]]; then
                    found_end=1
                else
                    echo "$line"
                fi
            fi
        done
    }

join/replace newlines in file with a new char/separator (.sh .bash): |
    function join_array { local IFS="$1"; shift; echo "$*"; }
    readarray -t ARRAY < FILE
    join_array "," "${ARRAY[@]}"

ascii terminal colours / bold/italic/underline tput (.sh .bash): |
    if [ -t 1 ]; then
        cblack=$(   2>/dev/null tput setaf 0) || true
        cred=$(     2>/dev/null tput setaf 1) || true
        cgreen=$(   2>/dev/null tput setaf 2) || true
        cyellow=$(  2>/dev/null tput setaf 3) || true
        cblue=$(    2>/dev/null tput setaf 4) || true
        cmagenta=$( 2>/dev/null tput setaf 5) || true
        ccyan=$(    2>/dev/null tput setaf 6) || true
        cwhite=$(   2>/dev/null tput setaf 7) || true
        creset=$(   2>/dev/null tput sgr0) || true

        cBblack=$(  2>/dev/null tput setab 0) || true
        cBred=$(    2>/dev/null tput setab 1) || true
        cBgreen=$(  2>/dev/null tput setab 2) || true
        cByellow=$( 2>/dev/null tput setab 3) || true
        cBblue=$(   2>/dev/null tput setab 4) || true
        cBmagent=$( 2>/dev/null tput setab 5) || true
        cBcyan=$(   2>/dev/null tput setab 6) || true
        cBwhite=$(  2>/dev/null tput setab 7) || true

        cbold=$(        2>/dev/null tput bold) || true
        citalic=$(      2>/dev/null tput sitm) || true
        cunitalic=$(    2>/dev/null tput ritm) || true
        cunderline=$(   2>/dev/null tput smul) || true
        cununderline=$( 2>/dev/null tput rmul) || true
    fi

first word of a string (.sh .bash): cut -d ' ' -f1

check if directory is empty (.sh .bash): is_dir_empty() { ! find "$1" -mindepth 1 -maxdepth 1 | read -r REPLY; }

cat heredoc to file (.sh .bash): |
    cat <<EOF > FILE
    ...
    EOF

git helper (.git .bash): |
    git_branch_exists() { [[ -z "$(git branch --list "$1")" ]]; }
    git_current_branch() { local head; head="$(git symbolic-ref HEAD)"; echo "${head:11}"; }

remove postfix/suffix (.bash): ${"/foo/bar"%/bar}
remove prefix (.bash): ${"/foo/bar"#/foo/}
default value for env/arg variable (.sh .bash): ${1:-default}

check if user exists (.sh .bash): |
    if id USERNAME &>/dev/null; then
        echo 'user found'
    fi

set variable to heredoc (.sh .bash): |
  read -r -d '' VAR <<EOF || true
  ...
  EOF

lock/unlock a file (.sh .bash): |
    # open file on fd 5
    exec 5<> "./lockme.json"
    flock 5
    # ...
    flock --unlock 5

open file as file descriptor (.sh .bash): exec 5<> "./lockme.json"
read lines of command into array (.bash): |
  readarray -t VARNAM < <(SOME_PROCESS)
read lines of file into array (.bash): |
  readarray -t VARNAME < FILEPATH
  readarray -t VARNAM < <(SOME_PROCESS)

write heredoc to file with sudo rights (.sh .bash): |
    sudo tee "FILEPATH" >/dev/null <<EOF
    ...
    EOF

extract/match regex groups (.bash): |
    if [[ "$line" =~ ^(.*):\ \"([^\"]+)\"$ ]]; then
        echo "${BASH_REMATCH[0]}" # full string
        echo "${BASH_REMATCH[1]}" # first group
        echo "${BASH_REMATCH[2]}" # second group
    fi

replace/remove substring (.zsh .bash): "\"${VARFOO//WORDTOREMOVE/}\""
check if script running as root (.sh .bash): "[[ $EUID -eq 0 ]]"
hashmap / declarative / associative array (.bash): |
  declare -A MAP
  MAP[foo]=bar
  echo "${MAP[foo]}"
  echo "keys" "${!MAP[@]}"
  echo "vals" "${MAP[@]}"

  # read
  while IFS='=' read -r key value; do
      MAP[$key]=$value
  done < FILENAME

  # write
  for e in "${!MAP[@]}"; do
      printf "%s=%s\n" "$e" "${MAP[$e]}" >> FILENAME
  done

all keys matching/equal-to a given value (.jq .sh .bash): |
    jq -e 'to_entries[] | select(.value=="xxx")) | .key'

first key matching/equal-to a given value (.jq .sh .bash): |
    jq -e 'first( to_entries[] | select(.value=="xxx")) | .key'

create json (.jq .sh .bash): |
    BUCKET_NAME=testbucket
    OBJECT_NAME=testworkflow-2.0.1.jar
    TARGET_LOCATION=/opt/test/testworkflow-2.0.1.jar

    JSON_STRING=$( jq -n \
                      --arg bn "$BUCKET_NAME" \
                      --arg on "$OBJECT_NAME" \
                      --arg tl "$TARGET_LOCATION" \
                      '{bucketname: $bn, objectname: $on, targetlocation: $tl}' )

write json object (.jq .sh .bash): |
  jq -nc \
      --arg foo "$foo" \
      --arg bar "$bar" \
      '{foo: $foo, bar: $bar}'

write array to json (.jq .bash): |
  manuallyEscapedArray=(100 '"numbers"' '"\n"' '"escaped newlines work fine in strings"')
  printf "%s\n" "${manuallyEscapedArray[@]}" | jq -s '.'

  allToStringArray=(100 "all-numbers-are-strings" "\n" "excessive escaping of escaped newlines")
  printf "%s\n" "${allToStringArray[@]}" | jq -s --raw-input 'split("\n")[:-1]'

cd/change dir to script parent location path (.bash): |
  # cd to parent dir of current script
  cd "$(dirname "${BASH_SOURCE[0]}")"

check if string/variable starts with (.sh .bash): '[[ $var == prefix* ]]'

list ls all files in directory (.sh .bash): |
    for file in "$search_dir"/*; do
        echo "$file"
    done

check if has stdin / is terminal (.sh .bash): |
    if [ -t 0 ]; then
        echo running interactivelly
    else
        while read -r line ; do
            echo $line
        done
    fi

wait for internet avail / ping google ping (.bash): |
    while ! ( set -e; for i in {1..2}; do ping -c 2 -w 2 -q 8.8.8.8; done ); do
        sleep 1
    done

kill/send ctrl-c/sigint to pid  (.sh .bash): kill -s SIGINT "$!"
get last pid (.sh .bash): '"$!"'

clear/unset trap (.sh .bash): |
    trap - INT EXIT

handle/trap ctrl-c (.sh .bash): |
    function ctrl_c() {
            echo "** Trapped CTRL-C"
    }
    trap ctrl_c INT

check if env variable is set (.sh .bash): '[[ -z "${MY_ENV}" ]]'

check/test if application/program/command exists/is installed (.sh .bash): |
    command -v COMMAND &>/dev/null || die "can't find program: COMMAND"

prompt/ask confirm/continue/key press (.sh .bash ;zsh): |
    prompt_continue() {
        tput sc
        while true; do
            read -p "${1:-Continue?} (y/n) " -n 1 -r yn
            case $yn in
                [Yy]*) break;;
                [Nn]*) printf "\n"; exit 1;;
                *) tput el1; tput rc ;;
            esac
        done
        printf "\n"
    }

test if glob has any matches (.sh .bash): |
    if compgen -G test/*; then
        :
    fi

detect os system / win / mac / linux (.sh .bash): |
    is_linux=
    is_windows=
    is_macos=
    case $OSTYPE in
        linux-gnu*)  is_linux=1 ;;
        darwin*)     is_macos=1 ;;
        cygwin|msys) is_windows=1 ;;
        *) printf "ERROR: could not determine OS via \$OSTYPE" >&2; exit 1 ;;
    esac

interpret/render metacharacters from script output (.sh .bash): col -bp < "./typescript"

print to stderr (.sh .bash): printf "%s\n" "$1" >&2

check if string is number (.sh .bash): |
    if [[ ! $yournumber =~ ^[0-9]+$ ]]; then
        echo "NAN"
    fi

create temporary file (.sh .bash): |
    tmpfile=$(mktemp)
    cleanup_tmpfile() {
        rm "$tmpfile"
    }
    trap 'cleanup_tmpfile' EXIT

create temporary directory (.sh .bash): |
    tmpdir=$(mktemp -d)
    cleanup_tmpdir() {
        rm -rf "$tmpdir"
    }
    trap 'cleanup_tmpdir' EXIT

get parent directory of path (.sh .bash): parent=$(dirname "$file")

check if dir exists (.sh .bash): |
    [[ -d "$dir" ]] &&
check if file exists (.sh .bash): |
    [[ -f "$file" ]] &&

for each line in variable (.sh .bash): |
    while IFS= read -r line; do
        echo "$line"
    done <<< "$VAR"

for each line in file (.sh .bash): |
    # https://mywiki.wooledge.org/BashFAQ/001
    while IFS= read -r line || [[ -n "$line" ]]; do
        AlphaSignature="$line"
    done < "$ReleasePath/$AlphaKeyFile"

for each line of output (.bash): |
    while read -r line; do
        [[ "$line" == *"$(basename "$0")" ]] && continue # skip this script itself
        # all subprocesses here will inherit the command as stdin, not the tty, so we need to set it explicitly again
        vimdiff "$PWD/$line" "/$line" < /dev/tty
    done < <(find . -type f -name fname)

if string ends with substring / suffix (.sh .bash): |
    [[ $f == *"file.txt" ]] && continue # skip file.txt

capture regex group (.sh .bash): |
    echo "Geometry: 100x00" | grep -oP "Geometry: \K(.*)"

array (.bash .sh): |
    fooList=(foo bar "${fooList[@]}")
    fooList+=(baz)
    for foo in "${fooList[@]}"; do
        echo $foo
    done
    myfunc "${fooList[@]}"
    fooListLength=${#fooList[@]}

count / number of arguments (.sh .bash): '"$#"'

for each file in path (.sh .bash): |
    for path in ./*.json; do
        echo $path
    done

abspath / realpath (.sh .bash): |
    fabspath=$(realpath "$path")

extract/split file base,name,extension from path (.sh .bash): |
    fnamewext=$(basename -- "$path")
    fbase="${path%/*}"
    fext="${fnamewext##*.}"
    fname="${fnamewext%.*}"

kill background processes along with main process (.sh .bash): |
    bgpids=()
    trap '2>/dev/null kill "${bgpids[@]}"' EXIT
    longrunningprocess1 & bgpids+=("$!")
    longrunningprocess2 & bgpids+=("$!")
    wait
    unset 'bgpids[${#bgpids[@]}-2]'

defer exit (.sh .bash): |
    cleanups=()
    cleanup() {
        for cleanupScript in "${cleanups[@]}"; do
            eval "$cleanupScript"
        done
    }
    trap 'cleanup' EXIT

on/trap error (.bash): |
    on_error() {
        echo "ASD"
    }
    trap 'on_error' ERR

date-alphabetical-sort (.cmd .sh .bash): date +%Y.%m.%d\ %T\ +%Z

date-short-time (.cmd .sh .bash): date +%T
date-posix (.cmd .sh .bash): date +%s
date-posix with days/offset (.cmd .sh .bash): date -d "2 days ago" +%s

# https://stackoverflow.com/a/35638712
func is_nohup (.sh .bash): |
    is_nohup() {
        grep -Eq 'SigIgn:\s.{15}[13579bdf]' "/proc/$$/status" && return 0 || return 1
    }

die (.sh .bash): |
    die() {
        printf '%b\n' "$1" >&2
        exit "${2-1}"
    }

die usage usage_and_die (.sh .bash): |
    die() {
        printf '%b\n' "$1" >&2
        exit "${2-1}"
    }
    usage() {
        echo "usage: [-h|--help] <file>"
        exit "${1-0}"
    }
    usage_and_die() {
        printf '%b\n' "$1" >&2
        usage "${2-1}"
    }

foreach argument (.sh .bash): |
    for arg in "$@"; do
        echo "$arg"
    done

echo heredoc (.sh .bash): |
    cat <<EOF
    ...
    EOF

# https://mywiki.wooledge.org/BashFAQ/035
cli, parseargs argument parsing cli (.sh .bash): |
    usage() {
        echo "usage: [-h|--help] <file>"
        exit "${1-0}"
    }
    while :; do
        case $1 in
            -h|-\?|--help)
                usage 0 ;;
            -f|--file)
                [[ ! "$2" ]] && die "ERROR: '$1' requires a non-empty option argument."
                file=$2
                shift || usage
                ;;
            --)
                shift || usage
                break
                ;;
            -?*) printf 'WARN: Unknown option (ignored): %s\n' "$1" >&2 ;;
            *) break ;;
        esac

        shift || usage
    done

# {{{2 Templates
push rsync script (.templ .sh .bash): |
  #!/bin/bash
  set -eo pipefail

  # cd to parent dir of current script
  cd "$(dirname "${BASH_SOURCE[0]}")"

  files=(
      "$PWD/./foo/CHNG_FILE"
  )

  printf "%s\n" "${files[@]}" | rsync --files-from "-" "/" "$(rsync-hosts CHNG_HOST)"

# html/css {{{1
include a css /file (.html .css): |
    <link rel="stylesheet" href="styles.css">
    <style>
        body {background-color: powderblue;}
        h1   {color: blue;}
        p    {color: red;}
    </style>

include a javascript /file (.html .css): |
    <script src="javascript.js"></script>
    <script>
        alert("Hello World!");
    </script>

# systemd {{{1
simple shell script (.systemd .service): |
    [Unit]

    [Service]
    User=root
    Type=idle
    ExecStart=/root/postinstall.sh

    [Install]
    WantedBy=multi-user.target

# various {{{1
date-alphabetical-sort (.run):
    cmd: bash
    stdin: date +%Y.%m.%d\ %T\ +%Z | head -c -1

vim run compile (.c .vim .various): // [RUN] bear -- gcc $(pkg-config --cflags --libs gtk+-3.0) "%" -o "%.out"
vim run compile (.c .vim .various): // [RUN] bear -- gcc $(pkg-config --cflags --libs gtk+-3.0) "%" -o "%.out"
vim run compile (.cpp .vim .various): // [RUN] bear -- clang++ $(pkg-config --cflags --libs libpcrecpp jsoncpp) "%" -o "%.out"

vim modeline for basic text (.vim .various): |
  // vim: set noai tw=80 nosmartindent:
vim modeline for setting filetype (.vim .various): |
  # vim: set ft=nginx syn=nginx:
vim modeline for setting indentation settings (.vim .various): |
  # vim: set ts=4 sw=4 et:
vim modeline for setting comment string (.vim .various): |
  # vim: set commentstring=#\ %s:
show term cursor again via tput (.gdb): 'shell tput cnorm'

utf8/unicode symbols (.various): |
  ⇑ ↑ ▲ ⬆ ⇡ ⤊ ↥
  ← → ↑ ↓ ⟵ ⟶ ⇦ ⇨ ⇧ ⇩ ⬅ ( ⮕ ➡ ) ⬆ ⬇
  ↔ ↕ ↚ ⇳ ⬍
  ↖ ↗ ↘ ↙ ⬁ ⬀ ⬂ ⬃ ⬉ ⬈ ⬊ ⬋
  ⇠ ⇢ ⇡ ⇣
  ⛯ ¦ ∞ ☇ ∷ ⋮ ★ ⚕ ➶ ➚ → ➺ ➧ @ ✿ ℭ ⏸
  ✓ ✗ ✘ 𐄂
  ↺ ↻ ⟲ ⟳ ⭯ ⭮ ↺ ↻ ⥀ ⥁ ⮌ ⮍ ⮎ ⮏ ⤸ ⤹
  😀 😃 😄 😁 😆 😅 😂 🙂 🙃 😉 😊 😇 🥰 😍 ☺ 😞
  🤖 😺 😸 😹 😻 😼 😽 🙀 😿 😾
  💋 💌 💘 💝 💖 💗 💓 💞 💕 💟 ❣ 💔
  🧡 💛 💚 💙 💜 🤎 🖤 🤍 💯 💢 💥 💫 💦 💨
  💣 💬 💭 💤 👋 🤚 🖐 ✋ 🖖 🤌 🤏 ✌ 🤞 🤟 🤘 🤙
  👈 👉 👆 🖕 👇 👍 👎 ✊ 👊 🤛 🤜 👏 🙌 👐 🤲 🤝
  🙏 💅 🤳 💪 🦾 🦿 🦵 🦶 👂 🦻 👃 🧠 🫀 🫁 🦷 🦴 👀
# vim: set ts=4 sw=4 et:
