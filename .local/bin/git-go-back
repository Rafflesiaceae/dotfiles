#!/usr/bin/env bash
# git-go-back v0.2 (2023-01-24) (776086aa4c3899c3)
# go back to a still existing previously checked out branch ( W O W )
set -eo pipefail

# parse reflog
checkout_history=()
while read -r line; do
    if [[ "$line" =~ ^checkout:\ moving\ from\ ([^\ ]+)\ to\ ([^\ ]+)$ ]]; then
        to="${BASH_REMATCH[2]}"
        checkout_history+=("$to")
    fi
done < <(git reflog --since="7 day ago" --format=%gs)

# filter duplicates
remove_duplicates() { awk '!a[$0]++'; }
readarray -t checkout_history < <(printf "%s\n" "${checkout_history[@]}" | remove_duplicates)

# filter dead branches
readarray -t nondead_local_branches < <(git for-each-ref --format='%(refname:short)' refs/heads/)
nondead_checkout_history=()
for br in "${checkout_history[@]}"; do
    # shellcheck disable=SC2076
    if [[ " ${nondead_local_branches[*]} " =~ " ${br} " ]]; then
        nondead_checkout_history+=("$br")
    fi
done

# Deduplicate an array in place, preserving first occurrences.
# Usage:
#   arr=(a b a c "with space" b "" "")
#   uniq_inplace           # operates on 'arr' by default
#   # or: uniq_inplace arr # explicit array name
uniq_inplace() {
  local -n _arr="${1:-arr}"  # nameref to target array (Bash â‰¥ 4.3)
  declare -A _seen=()
  local _out=() x

  for x in "${_arr[@]}"; do
    if [[ -z ${_seen[$x]+_} ]]; then
      _out+=("$x")
      _seen["$x"]=1
    fi
  done

  _arr=("${_out[@]}")
}

nondead_checkout_history+=("$(git-default-branch -l)")

uniq_inplace nondead_checkout_history

if [[ "$1" == "co" ]] && [[ -n "$2" ]]; then
    git checkout --quiet "${nondead_checkout_history[$2]}"
elif [[ -n "$1" ]]; then
    printf "%s\n" "${nondead_checkout_history["$1"]}"
else
    # prompt and checkout
    uncaused_will_or_conscious_choice=$(printf "%s\n" "${nondead_checkout_history[@]}" | fzf) || exit 0
    git checkout --quiet "$uncaused_will_or_conscious_choice"
fi
