#!/usr/bin/env bash
# edit-and-amend.sh
# Usage: ./edit-and-amend.sh <commit-ish>
# Set INCLUDE_UNTRACKED=1 to include untracked files in the temporary stash.

set -Eeuo pipefail

err() { printf "\e[31mERROR:\e[0m %s\n" "$*" >&2; }
info() { printf "\e[36m==>\e[0m %s\n" "$*"; }

# Never recurse into submodules for ANY git command:
git_nr() { git -c submodule.recurse=false "$@"; }

# ---- Preflight --------------------------------------------------------------
if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    err "Not inside a git repository."
    exit 1
fi

if [ $# -ne 1 ]; then
    err "Expected exactly one argument: the commit id to edit."
    echo "Usage: $0 <commit-ish>"
    exit 1
fi

TARGET_COMMIT="$1"
INCLUDE_UNTRACKED="${INCLUDE_UNTRACKED:-0}"

# Fallback sentinel
if [[ "$TARGET_COMMIT" == "0000000000000000000000000000000000000000" ]]; then
    git_nr commit --amend
    exit 0
fi

if ! git rev-parse --verify "${TARGET_COMMIT}^{commit}" >/dev/null 2>&1; then
    err "Argument '${TARGET_COMMIT}' is not a valid commit."
    exit 1
fi

git_nr update-index -q --refresh || true

# 1) require staged changes
if git_nr diff --cached --quiet; then
    # err "There are no staged changes. Aborting as requested."
    git commit --amend
    exit 0
fi
info "Detected staged changes."

# ---- Workspace --------------------------------------------------------------
TMPDIR="$(mktemp -d -t edit-amend.XXXXXX)"
cleanup() { rm -rf "$TMPDIR"; }
trap cleanup EXIT

ALL_STAGED="$TMPDIR/all_staged.nul"
ALLOWED_NUL="$TMPDIR/allowed.nul"
PATCH="$TMPDIR/staged.patch"

# Track stash breadcrumb so we can tell the user on early exit
UNSTAGED_STASHED=0
UNSTAGED_STASH_REF=""

# If the script exits early and we created a stash, tell the user how to restore it
announce_stash_on_exit() {
    if [ "$UNSTAGED_STASHED" -eq 1 ] && [ -n "$UNSTAGED_STASH_REF" ]; then
        printf "\n\e[33mNOTE:\e[0m Your unstaged changes are safe in \e[1m%s\e[0m.\n" "$UNSTAGED_STASH_REF" >&2
        printf "Restore with:  git stash apply \"%s\"\n\n" "$UNSTAGED_STASH_REF" >&2
    fi
}
trap 'rc=$?; announce_stash_on_exit; exit $rc' INT TERM

# Collect staged paths (robust to spaces/newlines)
git_nr diff --cached --name-only -z >"$ALL_STAGED"

# Detect submodules (gitlinks, mode 160000)
SUBMODS_TXT="$TMPDIR/submods.txt"
: >"$SUBMODS_TXT"
git submodule--helper list 2>/dev/null | awk '{print $4}' >>"$SUBMODS_TXT" || true
git ls-files -s | awk '$1=="160000"{print $4}' >>"$SUBMODS_TXT" || true
sort -u -o "$SUBMODS_TXT" "$SUBMODS_TXT"

# Filter: exclude submodule paths
: >"$ALLOWED_NUL"
if [ -s "$ALL_STAGED" ]; then
    while IFS= read -r -d '' p; do
        grep -Fxq -- "$p" "$SUBMODS_TXT" && continue
        printf '%s\0' "$p" >>"$ALLOWED_NUL"
    done <"$ALL_STAGED"
fi

if [ ! -s "$ALLOWED_NUL" ]; then
    err "Only submodule pointer changes are staged; refusing to proceed to avoid repinning."
    exit 1
fi

# Load allowed paths into array
ALLOWED_ARR=()
if command -v mapfile >/dev/null 2>&1; then
    mapfile -d '' -t ALLOWED_ARR <"$ALLOWED_NUL"
else
    while IFS= read -r -d '' p; do ALLOWED_ARR+=("$p"); done <"$ALLOWED_NUL"
fi

# Serialize staged changes to a patch (only allowed paths)
git_nr diff --cached --binary -- "${ALLOWED_ARR[@]}" >"$PATCH"

# 2) stash UNSTAGED changes; by default DO NOT include untracked
if ! git_nr diff --quiet || { [ "$INCLUDE_UNTRACKED" -eq 1 ] && [ -n "$(git_nr ls-files --others --exclude-standard)" ]; }; then
    info "Stashing UNSTAGED changes... (include untracked: $INCLUDE_UNTRACKED)"
    STAMP="$(date -u +%Y%m%dT%H%M%SZ)"
    MSG="pre-edit:unstaged $STAMP"
    if [ "$INCLUDE_UNTRACKED" -eq 1 ]; then
        git_nr stash push -u -k -m "$MSG"
    else
        git_nr stash push -k -m "$MSG"
    fi
    UNSTAGED_STASHED=1
    # exact reference to this stash via reflog search
    UNSTAGED_STASH_REF="stash^{/$MSG}"
else
    info "No unstaged changes to stash."
fi

# 3) hide the staged changes (no stash; avoids gitlinks)
info "Temporarily hiding originally STAGED (non-submodule) changes..."
git_nr reset -q -- "${ALLOWED_ARR[@]}"
git_nr checkout -q -- "${ALLOWED_ARR[@]}"

# 4) edit the target commit
info "Editing commit ${TARGET_COMMIT} noninteractively..."
git-rebase-noninteractive-single --edit "${TARGET_COMMIT}"

# 5) restore previously staged changes
info "Restoring the previously staged changes..."
git_nr apply --3way --whitespace=nowarn "$PATCH"

# 6) re-stage exactly the original set (include deletions)
info "Staging restored changes (exact original set)..."
git_nr add -A -- "${ALLOWED_ARR[@]}"

# 7) amend (opens $EDITOR)
info "Amending commit (opening \$EDITOR for the message)..."
git_nr commit --amend

# 8) finish the edit
info "Continuing rebase/edit..."
git-continue

# 9) restore previously UNSTAGED changes and keep them unstaged
if [ "$UNSTAGED_STASHED" -eq 1 ]; then
    info "Restoring previously UNSTAGED changes..."
    # Use the exact ref we recorded
    if git_nr stash pop "$UNSTAGED_STASH_REF"; then
        UNSTAGED_STASHED=0
        UNSTAGED_STASH_REF=""
    else
        err "Failed to pop $UNSTAGED_STASH_REF. Resolve conflicts and apply manually:"
        printf "  git stash apply \"%s\"\n" "$UNSTAGED_STASH_REF" >&2
        exit 1
    fi
else
    info "No previously unstaged changes to restore."
fi

info "Done (submodules untouched)."
