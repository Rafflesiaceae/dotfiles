#!/usr/bin/env bash
# syncfs: push/pull a directory (marked by .syncfs) to/from a fixed remote using rsync.
# Remote dir     = ${SYNCFS_REMOTE}/${md5sum(realpath(syncdir))}
# Remote stamp   = ${SYNCFS_REMOTE}/${md5sum(realpath(syncdir))}.timestamp
# Local stamp    = <syncdir>/.syncfs   (stores POSIX seconds; file also acts as the marker)
set -u
# ------------ helpers ------------
die() { echo "Error: $*" >&2; exit 1; }
need() { command -v "$1" >/dev/null 2>&1 || die "required command not found: $1"; }
resolve_realpath() {
  local p="$1"
  if command -v realpath >/dev/null 2>&1; then realpath "$p"
  elif readlink -f . >/dev/null 2>&1; then readlink -f "$p"
  elif command -v python3 >/dev/null 2>&1; then
    python3 - "$p" <<'PY'
import os,sys
print(os.path.realpath(sys.argv[1]))
PY
  else die "cannot resolve realpath; install coreutils realpath or provide python3"; fi
}
md5_of_string() {
  if command -v md5sum >/dev/null 2>&1; then printf '%s' "$1" | md5sum | awk '{print $1}'
  elif command -v md5 >/dev/null 2>&1; then printf '%s' "$1" | md5 -q
  else die "need md5sum or md5"; fi
}
find_syncdir() {
  local dir="$PWD"
  while :; do
    if [ -e "$dir/.syncfs" ]; then printf '%s\n' "$dir"; return 0; fi
    [ "$dir" = "/" ] && return 1
    dir="$(dirname "$dir")"
  done
}
usage() {
  cat <<'EOF'
Usage: syncfs [push|pull] [-h|--help]
Synchronizes the directory that contains a `.syncfs` file (searched upwards from the current directory).
Subcommands:
  push   rsync local -> remote  (${SYNCFS_REMOTE}/${md5(realpath(syncdir))})
  pull   rsync remote -> local
No subcommand: prints status (based on rsync dry-runs and timestamps):
- Local changes to push
- Remote changes to pull (including when someone else pushed since your last local sync)
- Both directions
- Up to date
Environment:
  SYNCFS_REMOTE   Required. Base remote for rsync, e.g. "user@host:/var/syncfs" or a local path.
Notes:
  - Preserves perms and mtimes (-rlpt), not ownership. Excludes ".syncfs".
  - Local last-sync time is stored as POSIX seconds inside ".syncfs".
  - Remote last-push time is stored in "${SYNCFS_REMOTE}/${md5(realpath(syncdir))}.timestamp".
EOF
}
# rsync options: recursive, symlinks, perms (exec bits), times; itemize changes; exclude marker
RSYNC_OPTS=(-rlpt --itemize-changes --out-format='%i %n%L' --exclude='.syncfs')
remote_base() { printf '%s' "${SYNCFS_REMOTE%/}"; }
remote_path_for() {
  [ -n "${SYNCFS_REMOTE-}" ] || die "SYNCFS_REMOTE is not set"
  local real hash; real="$(resolve_realpath "$1")" || exit 1
  hash="$(md5_of_string "$real")" || exit 1
  printf '%s/%s' "$(remote_base)" "$hash"
}
remote_ts_path_for() {
  local real hash; real="$(resolve_realpath "$1")" || exit 1
  hash="$(md5_of_string "$real")" || exit 1
  printf '%s/%s.timestamp' "$(remote_base)" "$hash"
}
# Remote existence probes
remote_dir_exists() {
  local p="$1"
  case "$p" in
    /*|./*|../*) [ -d "$p" ] ;;
    *) rsync --list-only "$p/" >/dev/null 2>&1 ;;
  esac
}
remote_file_fetch() { # $1 remote-file, $2 local-dest; returns 0 on success
  local src="$1" dst="$2"
  case "$src" in
    /*|./*|../*) [ -f "$src" ] && cp -f "$src" "$dst" 2>/dev/null ;;
    *) rsync "$src" "$dst" >/dev/null 2>&1 ;;
  esac
}
# Dry-run that tolerates rsync 23/24 (common with GVFS/remote FS)
# 0 => has changes, 1 => no changes, 2 => fatal error
dry_changes_exist() {
  local src="$1" dst="$2" out rc
  out="$(rsync -n "${RSYNC_OPTS[@]}" "$src" "$dst" 2>&1)"; rc=$?
  case "$rc" in 0|23|24) ;; *) echo "$out" >&2; return 2 ;; esac
  printf '%s\n' "$out" | grep -Eq '^[<>chd\.\*]' && return 0 || return 1
}
# Timestamp IO (POSIX seconds)
get_local_ts() {
  local f="$1/.syncfs" v
  if [ -f "$f" ]; then
    v="$(head -n1 "$f" | grep -Eo '^[0-9]{1,}$' || true)"
    [ -n "$v" ] && printf '%s' "$v" && return 0
  fi
  printf '0'
}
set_local_ts() {
  local d="$1" ts="$2"
  printf '%s\n' "$ts" >"$d/.syncfs" || die "cannot write $d/.syncfs"
}
get_remote_ts() {
  local syncdir="$1" rf tmp v
  rf="$(remote_ts_path_for "$syncdir")"
  tmp="$(mktemp)"; trap 'rm -f "$tmp"' RETURN
  if remote_file_fetch "$rf" "$tmp"; then
    v="$(head -n1 "$tmp" | grep -Eo '^[0-9]{1,}$' || true)"
    [ -n "$v" ] && printf '%s' "$v" && return 0
  fi
  printf '0'
}
set_remote_ts() {
  local syncdir="$1" ts="$2" rf tmp
  rf="$(remote_ts_path_for "$syncdir")"
  tmp="$(mktemp)"; printf '%s\n' "$ts" >"$tmp"
  case "$rf" in
    /*|./*|../*) cp -f "$tmp" "$rf" ;;
    *) rsync "$tmp" "$rf" ;;
  esac || die "failed to write remote timestamp: $rf"
  rm -f "$tmp"
}
do_push() {
  local syncdir="$1" remote now
  remote="$(remote_path_for "$syncdir")" || exit 1
  echo "Pushing:"
  echo "  Local : $syncdir/"
  echo "  Remote: $remote/"
  rsync "${RSYNC_OPTS[@]}" "$syncdir/" "$remote/" || exit 1
  now="$(date +%s)"
  set_remote_ts "$syncdir" "$now"
  set_local_ts  "$syncdir" "$now"
}
do_pull() {
  local syncdir="$1" remote now
  remote="$(remote_path_for "$syncdir")" || exit 1
  if ! remote_dir_exists "$remote"; then
    echo "Nothing to pull: remote '$remote' does not exist yet."
    return 0
  fi
  echo "Pulling:"
  echo "  Remote: $remote/"
  echo "  Local : $syncdir/"
  rsync "${RSYNC_OPTS[@]}" "$remote/" "$syncdir/" || exit 1
  now="$(date +%s)"
  set_local_ts "$syncdir" "$now"
}
status_both_dirs() {
  local syncdir="$1" remote push_has=0 pull_has=0 remote_newer=0
  remote="$(remote_path_for "$syncdir")" || exit 1
  # rsync-based detection
  if dry_changes_exist "$syncdir/" "$remote/"; then
    push_has=1
  elif [ $? -ne 1 ]; then
    die "rsync dry-run (push) failed; is the remote reachable?"
  fi
  if remote_dir_exists "$remote"; then
    if dry_changes_exist "$remote/" "$syncdir/"; then
      pull_has=1
    elif [ $? -ne 1 ]; then
      die "rsync dry-run (pull) failed; is the remote reachable?"
    fi
  fi
  # timestamp-based detection
  local lts rts
  lts="$(get_local_ts "$syncdir")"
  rts="$(get_remote_ts "$syncdir")"
  if [ "$rts" -gt "$lts" ]; then
    remote_newer=1
  fi
  # Decision logic
  if [ "$push_has" -eq 1 ] && { [ "$pull_has" -eq 1 ] || [ "$remote_newer" -eq 1 ]; }; then
    echo "There are changes in BOTH directions: you can 'push' and 'pull'."
    [ "$remote_newer" -eq 1 ] && echo "(Remote has newer changes since your last local sync.)"
  elif [ "$push_has" -eq 1 ]; then
    echo "There are LOCAL changes to push."
  elif [ "$pull_has" -eq 1 ] || [ "$remote_newer" -eq 1 ]; then
    echo "There are REMOTE changes to pull."
    [ "$remote_newer" -eq 1 ] && echo "(Someone else likely pushed after your last local sync.)"
  else
    echo "Up to date. Nothing to push or pull."
  fi
}
# ------------ main ------------
need rsync
need awk
case "${1-}" in -h|--help) usage; exit 0 ;; esac
syncdir="$(find_syncdir)" || die "no .syncfs found from $PWD upwards"
[ -d "$syncdir" ] || die "syncdir does not exist: $syncdir"
: "${SYNCFS_REMOTE:?SYNCFS_REMOTE environment variable must be set}"
case "${1-}" in
  push) do_push "$syncdir" ;;
  pull) do_pull "$syncdir" ;;
  "" )  status_both_dirs "$syncdir" ;;
  *)    echo "Unknown subcommand: $1" >&2; usage >&2; exit 2 ;;
esac
